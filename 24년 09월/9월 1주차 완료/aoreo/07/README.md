# [백준 - 골드 3] 17135.캐슬 디펜스

## ⏰  **time**
5시간.. 그 이상..?

## :pushpin: **Algorithm**
조합 + bfs

## ⏲️**Time Complexity**
$O(N^2)$

## :round_pushpin: **Logic**
1. 배열을 직접 조작할 것이므로, 배열의 복사본 생성한다
2. Move class로 위치값과 움직인 횟수를 담는다
3. 궁수를 배치할 위치를 구하기 위해 조합 이용한다.
4. 한 턴의 위치를 다 구하면, 처치가능한 적 수를 계산한다.
5. 궁수의 수만큼 반복하며, 궁수의 위치를 queue에 넣고, 위, 양옆을 탐색한다
6. 적이 있을 경우, enemies[i]가 null이거나(처치한 적 없다면), 같은 거리인데 기존에 처치할 적보다 왼쪽에 있는 적이거나 더 가까운 적이라면 값으로 넣는다.
7. 적이 없다면, queue에 추가한다.
8. 반복문이 끝난 후, enemies에 담긴 적들을 0으로 처리하고, 처치수를 증가한다.
9. round를 통해 끝날 지점을 지정한다. round가 N보다 작을 경우에만 while문을 진행하고, 매 턴이 끝날 때 round를 증가시킨다.
10. while문을 빠져나와, answer보다 kills가 클 경우 answer 값을 업데이트한다.


## :black_nib: **Review**
막혔던 부분 백만개
1. 2차원 배열 복사할 때, 평소처럼 .clone()사용했는데... 알고보니 깊은 복사가 제대로 안되고 있었다... 알고보니 1차원 배열에만 통하는 방법이었고.... 

```
      copyMaps = new int[N][M];
      for (int i = 0; i < N; i++) {
        copyMaps[i] = maps[i].clone();
      }
```
2. 가장 왼쪽에 있는 적을 제거하기로 했기때문에 조건에 위치값을 비교하는 게 있었는데.. 이걸 y를 해야하는데 x로 비교해버린 똥멍청이
3. 진작 queue 쓸 걸, 되도 않는 반복문을 끼고 0일 경우 다음 시작값을 nx, ny로 설정했더니.. 제대로 값 설정 안됐었다 잉잉
4. 뭔가 배열을 계속해서 바꿔주는 게 부담이라 어디 블로그에서 본 궁수의 위치를 -1씩 올려주는 걸 하려고 했는데 제대로 못해서 ㅋㅎ.... 결국 실패하고 배열 계속 변경해주는 걸로 실행^~^...
5. 이동 수를 비교할 때 m.move +1로 비교하거나, 값을 넣어줘야하는데 +1 안해줘버리기 ...😮😮

## 📡 Link
[https://www.acmicpc.net/problem/17135](https://www.acmicpc.net/problem/17135)
