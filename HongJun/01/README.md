# [백준 - S4] 3048. 개미
https://www.acmicpc.net/problem/3048

## ⏰  **소요 시간**
30분

## :pushpin: **Algorithm**
- 구현
- 문자열

## ⏲️**Time Complexity (시간 복잡도)**
$O(N)$

## :round_pushpin: **Logic**
1. 두 개의 문자열을 입력받아 하나로 만든다.
    - 두 그룹이 서로 마주보기 때문에 첫 번째 문자열을 뒤집어 넣어야 함
2. 합친 문자열 크기 - 1 만큼 반복문으로 합친 문자열을 탐색한다.
    - i번째와 i+1번째를 비교해야하기 때문
    - i번째가 첫 번째 그룹, i+1번째가 두 번쨰 그룹이면 서로 다른 그룹 -> 마주보고 있는 상태임
    - 서로 자리를 바꿔줘야함
3. 반복문을 멈추는 조건을 넣어준다.
    - 자리를 바꾸고 반복문을 멈추지 않을 경우, 첫 번째 그룹의 맨 앞의 자리가 계속 바뀐다.
        - 예시) JLA / CRUO 입력
        - 합친 문자열: ALJ CRUO
        - 1초 지났을 때
            - i = 2일 때
            - J와 C가 다른 그룹이므로 자리가 바뀜 (A L C-J UO)
        - 반복문을 멈추지 않으면 J가 계속 다음 문자와 자리를 바꾸게 됨
            - i = 3일 때도 J와 U가 다른 그룹이기 때문에 자리를 바꾼다.
        - 2초 지났을 때
            - A L C J U O
            - i=1) L, C가 다른 그룹이므로 자리를 바꿈 (A C-L J U O)
            - i=2) L, J는 같은 그룹.
            - i=3) J, U는 다른 그룹이므로 자리를 바꿈 (A C-L U-J O)
    - 자리 이동은 첫 번쨰 그룹의 첫 문자가 전체 그룹의 i+1번 째에 위치할 때 끝난다.
        - first[0] == ant[i+1]
4. 입력한 t초 만큼 반복문이 끝나고 출력한다.

## :black_nib: **Review**
1. 처음에 두 그룹을 각각 입력받을 때 list(input().split())으로 입력 받았을 때 '\n'도 같이 리스트에 들어가버려서 틀렸다. -> input().split().strip()으로 해결했다.
2. 반복문을 빠져나오는 조건을 떠울리는데 시간이 좀 걸렸다. 머리로 시뮬레이션이 잘 안되서 코드마다 print하면서 문자열이 어떻게 변화하는지 확인하여 해결했다.