# ✅ \[백준 - 골드 4] 16197. 두 동전

## ⏰ **Time**

40분

## \:pushpin: **Algorithm**

BFS (완전탐색 + 상태 저장)

## ⏲️ **Time Complexity**

* 방문 배열 크기: `20×20×20×20 = 160,000`
* 각 상태에서 최대 4방향 → 완전탐색 가능
* 제한 조건 `cnt ≤ 10` → 상태 수가 제한됨

---

## \:round\_pushpin: **Problem Summary**

두 개의 동전을 동시에 상하좌우로 움직인다. 단, 둘 중 **하나만** 보드 밖으로 나가야 하며, **동시에 나가면 실패**.
**최소 몇 번 버튼을 눌러야 하나? (단, 최대 10번까지 가능)**

---

## \:round\_pushpin: **Logic Overview**

### ✅ 상태 정의

* 하나의 상태: `(x1, y1, x2, y2, cnt)`
* 각 동전의 위치와 현재 버튼 누른 횟수

### ✅ 이동 조건

1. **둘 중 하나만 떨어지면 → 성공 (정답 갱신)**
2. **둘 다 떨어지면 → 실패 (continue)**
3. **벽이면 이동하지 않음 (제자리)**
4. **이전 방문 상태면 skip** → `visited[22][22][22][22]` 사용

---

## 🧠 핵심 로직

```cpp
// 둘 중 하나만 나가면 성공
if ((isOut(nx1, ny1) && !isOut(nx2, ny2)) || (!isOut(nx1, ny1) && isOut(nx2, ny2))) {
    return cur.cnt + 1;
}

// 둘 다 나갔으면 실패
if (!isOut(nx1, ny1) && !isOut(nx2, ny2)) continue;

// 벽이면 이동 무시
if (board[nx1][ny1] == '#') { nx1 = cur.x1; ny1 = cur.y1; }
if (board[nx2][ny2] == '#') { nx2 = cur.x2; ny2 = cur.y2; }

// 방문 안 한 상태만 큐에 추가
if (!visited[nx1][ny1][nx2][ny2]) {
    visited[nx1][ny1][nx2][ny2] = true;
    q.push({nx1, ny1, nx2, ny2, cur.cnt + 1});
}
```

---

## ✅ 예외 처리

* `cnt > 10`이면 실패 (`-1` 반환)
* 시작 위치에 동전이 정확히 2개 있어야 함

---

## 🧪 예시

입력:

```
3 3
###
#oo
###
```

출력:

```
-1
```

입력:

```
3 5
#####
#..o#
#o..#
```

출력:

```
3
```

---

## \:black\_nib: **Review**

* 완전탐색인데 상태가 4차원이라 방문 배열이 핵심!
* 동전 하나만 떨어뜨려야 한다는 조건 때문에 조건문 처리가 매우 중요
* 벽을 만났을 때 **그 동전만 이동 무시하고 제자리**인 부분도 놓치기 쉬운 포인트

---

## 📡 Link

[🔗 백준 16197번 - 두 동전](https://www.acmicpc.net/problem/16197)
