# ✅ \[백준 - 골드 5] 15486. 퇴사 2

## ⏰ **Time**

15분

## \:pushpin: **Algorithm**

DP (1차원 동적 계획법)

## ⏲️ **Time Complexity**

\$O(N)\$

* 각 날짜에서 최대 1번만 갱신 작업 수행

---

## \:round\_pushpin: **Logic**

> 상담 일정이 주어졌을 때, 퇴사일까지 얻을 수 있는 **최대 수익**을 구하는 문제.

### 📌 핵심 아이디어

* 각 날짜 `i`에서 **오늘까지의 최대 수익**을 `dp[i]`에 저장한다.
* `i + day ≤ N`일 경우에만 상담을 선택할 수 있다.

---

### 🔸 동작 흐름

```cpp
for (int i = 0; i < n; i++) {
    cin >> day >> cost;

    // 현재 날짜까지 얻을 수 있는 최대 수익을 반영
    cur = max(cur, dp[i]);

    // 상담을 진행할 수 있다면, 그 종료일에 수익을 반영
    if (i + day <= n) {
        dp[i + day] = max(dp[i + day], cur + cost);
        result = max(result, dp[i + day]);
    }
}
```

### 🔸 변수 설명

* `dp[i]`: `i`일에 얻을 수 있는 최대 수익
* `cur`: `i` 이전 날짜까지의 최대 수익 중 가장 큰 값
* `result`: 전체 날짜 중 최대 수익

---

### ✅ 예시

입력:

```
7
3 10
5 20
1 10
1 20
2 15
4 40
2 200
```

처리 과정:

* 상담 1일차: 3일 소요 → 4일차에 10 누적
* 상담 3일차: 1일 소요 → 4일차에 누적 갱신
* ...
* 최종 최대 수익: `dp[7]` 혹은 `result`로 확인

---

## \:black\_nib: **Review**

* `cur = max(cur, dp[i])`를 통해 **이전 시점까지 누적 수익을 반영**하는 점이 핵심.
* 상담이 **겹치지 않도록** `i + day ≤ n` 체크는 필수.
* 전형적인 스케줄링 최적화 문제로, DP 구조가 간결하고 효율적.

---

## 📡 Link

[https://www.acmicpc.net/problem/15486](https://www.acmicpc.net/problem/15486)
