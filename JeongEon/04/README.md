# \[백준 - 실버 1] 16918. 봄버맨

## ⏰  **time**

25분

## \:pushpin: **Algorithm**

시뮬레이션 (시간 단계별 갱신)

## ⏲️**Time Complexity**

\$O(R \times C \times N)\$

* 한 타임스텝마다 격자 전체를 훑으며 폭탄 **증가/설치/폭발**을 처리

> 참고: 문제는 주기성이 있어 수학적으로는 주기를 이용해 \$O(RC)\$로도 가능하지만, 본 코드는 단계별 시뮬레이션 방식.

## \:round\_pushpin: **Logic**

1. **표현 방식**

   * `a[i][j] = -1` : 빈 칸
   * `a[i][j] >= 0` : 폭탄이 존재하며 “설치 후 지난 시간(초)”을 의미
   * 입력에서 `'O'`는 `0`(설치 직후), `'.'`는 `-1`로 세팅
2. **진행 규칙(봄버맨 규칙 반영)**

   * 홀수 초(1, 3, 5, …)에는 **시간만 흐름**(기존 폭탄들의 경과시간 +1)
   * 짝수 초(2, 4, 6, …)에는 **빈 칸에 전부 폭탄 설치**(= 모두 존재 상태로 증가)
   * **설치 3초가 지난 폭탄**은 그 시점에 **폭발**하며, 자신과 상하좌우를 빈 칸으로 만든다.
3. **구현 포인트**

   * 현재 시간 `T`를 올리며 각 단계에서

     1. 모든 칸의 시간을 +1
     2. **시간이 3이 된 좌표**를 벡터에 모아 일괄 폭파
   * 짝수/홀수 구분 없이 “**증가 → (필요 시) 폭파**” 패턴으로 두 번을 묶어 진행하면 규칙을 자연스럽게 반영 가능
4. **출력**

   * 최종 시간 `n`에 도달하면 `-1`은 `'.'`, 그 외는 `'O'`로 출력

### 핵심 스니펫

```cpp
// 폭발 예정 좌표 수집 후 일괄 처리
vector<pair<int,int>> v;
for (int i=0;i<r;i++){
  for (int j=0;j<c;j++){
    if (a[i][j] >= 0) a[i][j]++;     // 시간 경과
    if (a[i][j] == 3) v.push_back({i,j}); // 3초 → 폭발
  }
}
for (auto &p : v) {
  int x=p.first, y=p.second;
  a[x][y] = -1;
  for (int k=0;k<4;k++){
    int nx=x+dx[k], ny=y+dy[k];
    if (0<=nx && nx<r && 0<=ny && ny<c) a[nx][ny] = -1;
  }
}
```

## \:black\_nib: **Review**

* 폭탄을 “나이”로 관리하니 설치/폭발 타이밍이 한결 명확했다.
* 주기(2 또는 4 주기)를 이용하면 더 빠르게 풀 수 있지만, 시뮬레이션도 구현이 직관적이라 디버깅이 쉬웠다.

## 📡 Link

[https://www.acmicpc.net/problem/16918](https://www.acmicpc.net/problem/16918)
