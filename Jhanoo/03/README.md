# [백준 - G4] 팰린드롬?

## ⏰**time**

26분

## :pushpin: **Algorithm**

DP (Palindrome 구간 DP)

## ⏲️**Time Complexity**

$O(N^2 + M)$ (N: 수열 길이, M: 쿼리 수)

## :round_pushpin: **Logic**

1. 수열 길이 `N`과 수열 `a[1..N]`을 입력받는다.
2. `dp[l][r]`를 \([l, r]\) 구간이 팰린드롬인지 여부를 나타내는 boolean 배열로 선언한다.
3. 길이 1 구간은 항상 팰린드롬이므로, 모든 `i`에 대해 `dp[i][i] = true` 로 설정한다.
4. 길이 2 구간에 대해, `a[i] == a[i+1]` 인 경우에만 `dp[i][i+1] = true` 로 설정한다.
5. 길이 3 이상인 구간에 대해, 구간 길이 `len`을 3부터 N까지 증가시키면서 다음을 반복한다.
   - 왼쪽 끝 `l`을 1에서 시작해 `r = l + len - 1`이 N을 넘지 않을 때까지 증가시킨다.
   - `a[l] == a[r]` 이고, 내부 구간 `dp[l+1][r-1]` 이 `true` 라면 `dp[l][r] = true` 로 설정한다.
6. 이후 쿼리 개수 `M`을 입력받고, 각 쿼리마다 구간 `[S, E]`가 입력되면 `dp[S][E]`가 `true` 이면 `1`, 아니면 `0`을 출력한다.

```text
길이 1, 2 구간을 먼저 채우고
길이를 3부터 N까지 확장해 가며
양 끝 값이 같고 내부 구간이 팰린드롬이면 dp[l][r] = true 로 채운 뒤,
쿼리는 dp[S][E]만 바로 참조해 O(1)에 답한다.
```

## :black_nib: **Review**

- 전형적인 팰린드롬 구간 DP 문제로, 구간 길이를 기준으로 점화식을 세우면 깔끔하게 풀린다.
- 미리 모든 구간을 전처리해 두면 쿼리를 O(1)에 처리할 수 있어 효율적이다.

## 📡 Link

https://www.acmicpc.net/problem/10942
